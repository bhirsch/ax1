<?php
/**
 * @file ax1.module
 *  XML-RPC server and XML-RPC client for Aegir XML-RPC Sign Up module.
 */

/**
 * Implementation of hook_menu().
 */
function ax1_menu() {
  $items = array();

  $items['admin/settings/ax1'] = array(
    'title' => t('Ax1: Aegir XML-RPC Sign Up'), 
    'description' => t('Configure settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ax1_admin_settings'),
    'access arguments' => array('administer ax'), 
    'type' => MENU_NORMAL_ITEM,
    'file' => 'ax1.admin.inc', 
  );  

  return $items;
}

/**
 * Implementation of hook_form_alter().
 */
function ax1_form_alter(&$form, &$form_state, $form_id) {
dsm($form);
}
// */ 

/**
 * Implementation of hook_nodeapi().
 */
function ax1_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($op == 'view') {
    dsm($node);
  }
}

//-------------------------------
// xml-rpc server
//-------------------------------

/**
 * Implementation of hook_xmlrpc().
 * 
 * Map external names of XML-RPC methods to PHP callback functions.
 */
function ax1_xmlrpc() {
//  $methods['ax1.domains'] = 'xmls_ax1_domains'; // @TODO
  $methods['ax1.platforms'] = 'xmls_ax1_platforms';
  $methods['ax1.profiles'] = 'xmls_ax1_profiles';
//  $methods['ax1.dns'] = 'xmls_ax1_dns'; // see @TODO below
  $methods['ax1.status'] = 'xmls_ax1_status';
  $methods['ax1.createSite'] = 'xmls_ax1_createsite';

  return $methods;
}

/**
 * @param $key
 *  API key, string 
 * 
 * @return 
 *  List of available wildcard domains.
 */ 
/*
function xmls_ax1_domains($key) {
  $valid_key = variable_get('ax1_api_key', FALSE);
  if ($key == $valid_key) {
  
  } else {
    return t('Invalid API key.');
  }
}
// */

/**
 * @param $key
 *  API key, string 
 * 
 * @return 
 *  List available platforms and corresponding node IDs.
 */
function xmls_ax1_platforms($key) {
  $valid_key = variable_get('ax1_api_key', FALSE);
  if ($key == $valid_key) {
    $platforms = array();
    $result = db_query("SELECT nid, title FROM node WHERE type = 'platform'");
    while ($platform = db_fetch_object($result)) {
      $nid = $platform->nid;
      $title = $platform->title;
      $platforms[$nid] = $title;
    }
    return $platforms;
  } else {
    return t('Invalid API key.');
  }
}

/**
 * @param $key
 *  API key, string 
 * 
 * @return
 *  List available profiles. 
 */
function xmls_ax1_profiles($key) {
  $valid_key = variable_get('ax1_api_key', FALSE);
  if ($key == $valid_key) {
    $profiles = array();
    $result = db_query("SELECT nid, short_name "
                      ."FROM {hosting_package} "
                      ."WHERE package_type = 'profile'");
    while ($profile = db_fetch_object($result)) {
      $nid = $profile->nid;
      $short_name = $profile->short_name;
      $profiles[$nid] = $short_name;
    }
    return $profiles;
  } else {
    return t('Invalid API key.');
  }
}


/** @TODO validate domain name
 * @param
 *  $domain, string, requested domain name. 
 * 
 * @return
 *  Status of requested domain.
 */

/**
 * Check to see if domain already exists.
 */

/**
   @TODO If people just point registrar to name
   server and set up zone, can they just punch in 
   their own domain name and get a site up? Is 
   there any reason not to make name server 
   available to public? 
 * 
 * @return
 *  List of name servers.
 */

/**
 * @TODO Set up queue here, or may be run on cron. 
     If multiple people sign up for sites at once, this 
     seems like it could get messy. 
 */
function xmls_ax1_createsite($site) {

// CONTINUE HERE. CREATE NODE TYPE FOR SITE ON AX2 SITE. SAVE. CALL THIS ON CRON.

  // new node object
  $node = new stdClass();

  // hard coded for site nodes
  $node->type = 'site';

  // required fields
  $node->title = $site->title;       // domain
  $node->client = (isset($site->client)) ? $site->client : 1;
  $node->platform = $site->platform; 
  $node->profile = $site->profile; 
  $node->aliases = ($site->aliases) ? $site->aliases : ''; // array

  // optional, defaults here will work fine
  $node->uid = ($site->uid) ? $site->uid : 1; 
  $node->name = ($site->uid) ? user_load($site->uid)->name : user_load(1)->name;
  $node->language = ($site->language) ? $site->language : NULL; 
  $node->site_language = ($site->site_language) ? $site->site_language : 'en';
  $node->status = (isset($site->status)) ? $site->status : 1; 
  $node->comment = (isset($site->comment)) ? $site->comment : 0;
  $node->promote = (isset($site->promote)) ? $site->promote : 1;
  $node->moderate = ($site->moderate) ? $site->moderate : 0;
  $node->sticky = (isset($site->sticky)) ? $site->sticky : 0;
  $node->tnid = (isset($site->tnid)) ? $site->tnid : 0;
  $node->translate = (isset($site->translate)) ? $site->translate : 0;
  $node->body = ($site->body) ? $site->body : '';
  $node->teaser = ($site->teaser) ? $site->teaser : '';
  $node->log = ($site->log) ? $site->log : '';
  $node->format = ($site->format) ? $site->format : 0;
  $node->picture = ($site->picture) ? $site->picture : '';
  $node->db_server = ($site->db_server) ? $site->db_server : 2; // TODO required?
  $site_status (isset($site->site_status)) ? $site->site_statu : 1;
  $node->port = ($site->port) ? $site->port : 80;
  $node->ssl = ($site->ssl) ? $site->ssl : 0;
  $node->ssl_redirect = ($site->ssl_redirect) ? $site->ssl_redirect : 0;
  $node->redirection = (isset($site->redirection)) ? $site->redirection : 1;
  $node->build_mode = ($site->build_mode) ? $site->build_mode : 0;

  // automatically generated on node_save (I think)
  // $node->created
  // $node->changed
  // $node->vid
  // $node->revision_ui
  // $node->revision_timestamp
  // $node->date // TODO Do we need to store anything here? 
  // $node->last_cron
  // $node->verified  // TODO ? 
 
  node_save($node);
}

//-------------------------------
// xml-rpc client
//-------------------------------



